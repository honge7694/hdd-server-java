# Kafka 기초 다지기

## 1.Kafka 핵심 개념

### 카프카란?
아파치 카프카는 대용량의 실시간 데이터를 안정적으로 처리하기위해 설계된 **분산 이벤트 스트리밍 플랫폼**입니다.
단순히 메시지를 한곳에서 다른 곳으로 전달하는 **메시지 큐**의 역할을 넘어, 프로듀서가 보낸 메시지(데이터)를 디스크에 영속적으로 저장하고, 여러 컨슈머들이 필요할 때마다 이 데이터를 독립적으로 가져가서 처리(스트림 처리)할 수 있는 강력한 기능을 제공합니다.
링크드 인에서 처음 개발되었으며, 현재는 MSA 환경에서 서비스 간의 비동기 통신을 위한 사실상의 표준 기술로 자리 잡았습니다.

### 카프카의 장단점
**장점**
   - 높은 처리량 : 디스크에 순차적으로 데이터를 쓰고 읽는 방식과 OS의 페이지 캐시를 활용하여 대량의 메시지를 빠르게 처리할 수 있습니다.
   - 확장성 : 여러 대의 브로커로 클러스터를 구성하고, 필요에 따라 브로커를 쉽게 추가하여 시스템을 수평적으로 확장(Scale-out)할 수 있습니다.
   - 고가용성 및 내구성 : 여러 브로커에 데이터를 복제하여 저장하므로, 일부 브로커에 장애가 발생해도 데이터 유실 없이 안정적으로 서비스를 운영할 수 있습니다.
   - 느슨한 결합 : 프로듀서와 컨슈머가 서로를 직접 알지 못하고 오직 카프카를 통해서만 통신하므로, 서비스 간의 의존성을 크게 낮춰 MSA 환경에 매우 적합합니다.

**단점**
   - 운영 복잡성: 클러스터, 주키퍼(또는 KRaft), 브로커, 파티션 등 관리해야 할 요소가 많아 초기 설정과 운영의 복잡도가 높습니다.
   - 메시지 순서 보장의 제약: 파티션 내에서는 순서를 보장하지만, 여러 파티션에 걸친 전체 메시지의 순서는 보장하지 않습니다. 글로벌 순서 보장이 필요할 경우, 모든 메시지를 단일 파티션으로 보내야 하므로 병렬 처리의 이점을 잃게 됩니다.
   - 높은 학습 곡선: 분산 시스템에 대한 깊은 이해가 필요하며, 다양한 설정을 최적화하기 위한 학습이 요구됩니다.

### 용어 정리
**Broker(브로커)** 
  - **정의** : Kafka 서버 한 대를 의미합니다. 여러 브로커가 모여 하나의 **클러스터(Cluster)**를 구성할 수 있습니다.
  - **심화 설명** : 브로커는 단순히 메시지를 저장하는 창고 이상의 역할을 합니다. 클러스터 내의 각 브로커는 파티션의 데이터를 저장하고, 클라이언트(프로듀서/컨슈머)의 요청을 처리하며, 다른 브로커들과 데이터를 복제하는 등 분산 시스템의 역할을 수행합니다.
  - **관련 개념**
    - **클러스터(Cluster)** : 여러 브로커를 묶은 하나의 논리적인 Kafka 시스템입니다. 클러스터를 통해 특정 브로커에 장애가 발생해도 서비스 중단 없이 운영할 수 있는 **고가용성**과 여러 서버로 부하를 분산하는 **확장성**을 확보합니다.
    - **컨트롤러(Controller)** : 클러스터 내의 브로커 중 단 한대만 맡는 특별한 역할입니다. 클러스터의 다른 브로커들의 상태를 감시하고, 브로커가 다운되면 해당 브로커에 있던 파티션의 리더를 **다른 브로커로 재할당**하는 등 클러스터 전체를 관리하고 조정합니다.
      - **주키퍼(Zookeeper)/KRaft** : 카프카 클러스터가 컨트롤러를 선출하고 클러스터의 중요한 메타데이터(브로커 목록, 토픽 설정 등)을 관리하기 위해 사용하는 조정 시스템입니다.(최신 카프카는 주키퍼 없이 KRaft 프로토콜을 사용하는 방향으로 발전하고 있습니다.)

**Topic(토픽)**
   - **정의** : 메시지를 구분하는 논리적인 단위입니다. 데이터베이스의 '테이블'이나 메신저의 '채팅방'과 같습니다. 예를 들어, `order-events`, `user-signup`과 같이 목적에 따라 만듭니다.
   - **심화 설명** : 토픽은 프로듀서와 컨슈머가 메시지를 주고받는 채널의 이름입니다. 실제 데이터는 토픽을 구성하는 여러 개의 파티션에 분산되어 저장됩니다. 토픽을 생성할 때는 파티션 개수와 복제 계수를 설정하여 성능과 안정성을 조절할 수 있습니다.
   - **관련 개념**
      - **Replication Factor** : 데이터의 안정성을 위해 각 파티션의 복제본을 몇개나 만들지 결정하는 설정입니다. `Repication Factor`가 3이라면, 원본 1개와 복제본 2개의 총 3개의 데이터가 서로 다른 브로커에 저장되어 최대 2개의 브로커 장애까지 견딜 수 있습니다.

**Producer(프로듀서/생산자)** 
   - **정의** : 토픽으로 메시지를 보내는 애플리케이션입니다.
   - **심화 설명** : 프로듀서는 단순히 메시지를 보내는 것뿐만 아니라, 어떤 파티션으로 보낼지 결정하고, 데이터를 효율적으로 압축하며, 브로커로부터 메시지가 안전하게 저장되었다는 응답(Ack)을 받는 등 안정적인 데이터 전송을 위한 다양한 역할을 수행합니다.
   - **관련 개념**
     - 파티셔너(Partioner) : 메시지에 포함된 Key를 바탕으로 어떤 파티션에 메시지를 보낼지 결정하는 컴포넌트입니다. Key가 없으면 `Round Robin` 또는 `Sticky` 파티셔닝 전략을 통해 효율적으로 전송합니다.
     - Ack(Acknowledgement) : 프로듀서가 보낸 메시지가 브로커에 얼마나 안정적으로 저장되었는지 확인하는 응답 설정입니다. acks=all로 설정하면 모든 복제본에 저장이 완료된 후 응답을 받아 데이터 유실 가능성을 최소화 할 수 있습니다.
     - 배치(Batch): 프로듀서가 메시지를 즉시 보내지 않고, 내부 버퍼에 모아두었다가 한 번에 보내는 데이터 묶음입니다. 배치를 통해 네트워크 요청을 최소화하여 처리량을 극대화합니다. (batch.size, linger.ms 설정으로 제어)

**Consumer(컨슈머/소비자)**
   - **정의** : 토픽의 메시지를 가져와서 처리하는 애플리케이션입니다.
   - **심화 설명** : 컨슈머는 브로커로부터 메시지를 가져와 비즈니스 로직을 처리합니다. 여러 컨슈머를 하나의 그룹으로 묶어 작업을 병렬로 처리함으로써 높은 처리량을 달성할 수 있습니다.
   - **관련 개념**
     - 컨슈머 그룹 (Consumer Group): 동일한 기능을 수행하는 여러 컨슈머 인스턴스를 묶은 논리적인 단위입니다. 하나의 토픽에 있는 메시지는 각 컨슈머 그룹에게 딱 한 번씩만 전달됩니다. 그룹 내에서는 각 컨슈머가 서로 다른 파티션을 할당받아 작업을 병렬로 처리합니다.
     - 오프셋 (Offset): 각 파티션 내에서 메시지의 순서를 나타내는 고유한 번호(ID)입니다. 컨슈머 그룹은 특정 파티션의 메시지를 어디까지 읽었는지 이 오프셋을 기록해 둡니다. 만약 컨슈머에 장애가 발생했다가 복구되면, 마지막으로 기록된 오프셋부터 다시 메시지를 읽어 중복 처리나 유실을 방지합니다.
     - 그룹 코디네이터 (Group Coordinator): 클러스터의 브로커 중 하나가 맡는 역할로, 특정 컨슈머 그룹의 상태를 관리합니다. 그룹 내 컨슈머들의 상태를 추적하고, 새로운 컨슈머가 참여하거나 기존 컨슈머가 이탈할 때 파티션을 재할당하는 **리밸런싱(Rebalancing)** 을 지시합니다.

**Partition(파티션)** 
   - **정의** : 하나의 토픽은 여러개의 파티션으로 나뉠 수 있습니다. 메시지는 각 파티션에 순서대로 저장됩니다.
   - **심화 설명** : 파티션은 카프카의 **병렬 처리와 확장성**을 가능하게 하는 가장 핵심적인 물리 단위입니다. 하나의 토픽을 여러 파티션으로 나누고, 이 파티션들을 클러스터의 여러 브로커에 분산 배치함으로써 부하를 나누고 장애에 대응합니다.
   - **관련 개념**
     - 리더(Leader)와 팔로워(Follower): 각 파티션은 하나의 리더와 여러 개의 팔로워 복제본으로 구성됩니다. 모든 읽기/쓰기 요청은 오직 리더를 통해서만 처리되며, 팔로워는 리더의 데이터를 실시간으로 복제하는 백업역할을 합니다.
     - 리더 선출(Leader Election): 리더 파티션을 가진 브로커에 장애가 발생하면, 컨트롤러는 해당 파티션의 팔로워 중 하나를 새로운 리더로 승격시켜 서비스가 중단되지 않도록 합니다.
     - 순서 보장 : 카프카는 **파티션 내에서는 메시지의 순서를 보장**하지만, 여러 파티션에 걸친 전체 메시지의 순서는 보장하지 않습니다. 따라서 순서 보장이 중요한 데이터는 반드시 **동일한 Key를 사용**하여 같은 파티션으로 보내야합니다. 


## 2. Kafka 메시지 흐름
브로커 A, B, C와 컨슈머 A, B, C가 존재한다고 가정합니다.

### 시나리오 1: Key를 갖는 메시지를 `order-events` Topic에 보내는 경우
- 목표 : 특정 `orderId` Key와 관련된 모든 이벤트의 **처리 순서를 보장**하는 것
1. **[프로듀서]** order-events 토픽으로 orderId를 Key로 하는 메시지를 생성합니다.
2. **[프로듀서 → 카프카]** 프로듀서는 카프카 클러스터에 접속하여 메타데이터(클러스터 구조 정보)를 요청하고 캐싱합니다.
3. **[프로듀서 내부]** 프로듀서는 orderId 키의 해시값을 계산하여 메시지가 들어갈 파티션 번호를 결정합니다. (예: hash(orderId) % 3 = 파티션 1)
4. **[프로듀서 내부]** 캐시된 메타데이터를 통해, '파티션 1'의 리더는 **'브로커 A'**에 있다는 정보를 확인합니다.
5. **[프로듀서 → 브로커 A]** 프로듀서는 '브로커 A'에 직접 접속하여 메시지를 '파티션 1'에 씁니다.
6. **[컨슈머 그룹]** order-events 토픽을 구독하는 컨슈머 그룹(컨슈머 A, B, C)이 있고, 컨슈머 A가 '파티션 1'을 담당하도록 할당받았습니다.
7. **[컨슈머 A → 브로커 A]** 컨슈머 A는 주기적으로 '브로커 A'의 '파티션 1'에 새로운 메시지가 있는지 물어보고(Poll), 새 메시지를 가져갑니다(Pull).
8. **[컨슈머 A]** 가져온 메시지를 기반으로 비즈니스 로직을 실행합니다. 동일한 orderId를 가진 모든 메시지는 항상 파티션 1을 통해 컨슈머 A에게만 전달되므로 순서가 보장됩니다.

### 시나리오 2: Key를 갖지 않는 메시지를 `order-events` Topic에 보내는 경우 (라운드 로빈)
- 목표: 메시지 처리 순서보다는, 전체 처리량을 높이기 위해 **부하를 분산**하는 것.
1. [프로듀서] Key 없이 order-events 토픽으로 여러 개의 메시지를 연속으로 보냅니다. (예: 메시지 #1, #2, #3)
2. [프로듀서 내부] 프로듀서는 라운드 로빈(Round-Robin) 전략에 따라, 각 메시지를 보낼 파티션을 순서대로 결정합니다.
    - 메시지 #1 → 파티션 1 (리더: 브로커 A)
    - 메시지 #2 → 파티션 2 (리더: 브로커 C)
    - 메시지 #3 → 파티션 3 (리더: 브로커 B)
3. [프로듀서 → 브로커 A, C, B] 프로듀서는 각 메시지를 해당 파티션의 리더 브로커에게 개별적으로 전송합니다. (이 과정에서 메시지 하나당 네트워크 요청이 발생할 수 있습니다.)
4. [컨슈머 그룹] `order-events` 토픽을 구독하는 컨슈머 그룹(컨슈머 A, B, C)이 있고, 리밸런싱을 통해 각자 파티션을 할당받았습니다.
    - 컨슈머 A → '파티션 1' 담당
    - 컨슈머 C → '파티션 2' 담당
    - 컨슈머 B → '파티션 3' 담당
5. [각 컨슈머 → 각 브로커] 각 컨슈머는 동시에 자신이 담당하는 파티션의 리더 브로커에 접속하여 메시지를 가져갑니다(Pull).
    - 컨슈머 A는 '브로커 A'의 '파티션 1'에서 메시지 #1을 가져갑니다.
    - 컨슈머 C는 '브로커 C'의 '파티션 2'에서 메시지 #2를 가져갑니다.
    - 컨슈머 B는 '브로커 B'의 '파티션 3'에서 메시지 #3을 가져갑니다.
6. [각 컨슈머] 각자 가져온 메시지를 기반으로 비즈니스 로직을 실행합니다. 3개의 메시지가 3대의 컨슈머에 의해 병렬로 처리되어 전체 처리량이 높아집니다.

### 시나리오 3: Key를 갖지 않는 메시지를 `order-events` Topic에 보내는 경우 (스티키 파티셔닝)
- 목표 : 메시지 처리 순서보다는, 전체 처리량을 높이기 위해 **부하를 분산**하는 것.
1. **[프로듀서]** 이번에는 Key 없이 order-events 토픽으로 메시지를 보냅니다.
2. **[프로듀서 내부]** 프로듀서는 스티키 파티셔닝(Sticky Partitioning) 전략에 따라 메시지를 보낼 파티션을 결정합니다. 현재 배치의 목적지가 **'파티션 2'**로 결정되었다고 가정합니다.
3. **[프로듀서 내부]** 캐시된 메타데이터를 통해, '파티션 2'의 리더는 **'브로커 B'**에 있다는 정보를 확인합니다.
4. **[프로듀서 → 브로커 B]** 프로듀서는 내부 버퍼에 모아둔 메시지 배치(Batch)를 '브로커 B'의 '파티션 2'에 한 번의 요청으로 씁니다.
5. **[컨슈머 그룹]** order-events 토픽을 구독하는 컨슈머 그룹(컨슈머 A, B, C)이 있고, 컨슈머 B가 '파티션 2'를 담당하도록 할당받았습니다.
6. **[컨슈머 B → 브로커 B]** 컨슈머 B는 주기적으로 '브로커 B'의 '파티션 2'에 새로운 메시지가 있는지 물어보고(Poll), 새 메시지를 가져갑니다(Pull).
7. **[컨슈머 B]** 가져온 메시지를 기반으로 비즈니스 로직을 실행합니다. 다른 파티션으로 가는 메시지들은 다른 컨슈머(A, C)들이 동시에 처리하므로 전체 처리량이 높아집니다.
